{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap ba7a620d0cc3e93ea18b","webpack:///./src/main.js","webpack:///./src/model.js","webpack:///./src/backbone+.js","webpack:///./src/object+.js","webpack:///external {\"commonjs\":\"backbone\",\"commonjs2\":\"backbone\",\"amd\":\"backbone\",\"root\":\"Backbone\"}","webpack:///./src/modelset.js","webpack:///external {\"commonjs\":\"underscore\",\"commonjs2\":\"underscore\",\"amd\":\"underscore\",\"root\":\"_\"}","webpack:///./src/errors.js","webpack:///./src/attribute.js","webpack:///./src/collection.js","webpack:///./src/relations.js","webpack:///./src/metatypes.js","webpack:///./src/store.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B,gBAAgB;AAC3C,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,EAAC,G;;;;;;AC7CD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,qBAAoB,oBAAoB,oBAAoB,4BAA4B;AACxF;;AAEA;;AAEA,2BAA0B,WAAW,EAAE;;AAEvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAwC,gBAAgB;AACxD;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gEAA+D;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,yCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,oCAAmC,qBAAqB,EAAE;;AAE1D;AACA;AACA;AACA,MAAK;;AAEL;AACA,4BAA2B,qBAAqB,cAAc,GAAG,EAAE;;AAEnE;AACA;AACA;AACA,uBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL,+BAA8B,4BAA4B,EAAE;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb,MAAK;;AAEL;AACA,EAAC;AACD;AACA,kCAAiC,sBAAsB,mBAAmB,GAAG,EAAE;;AAE/E;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+BAA8B;AAC9B;AACA,wEAAuE;;AAEvE;AACA;AACA,EAAC;;AAED;AACA;AACA,gFAA+E;AAC/E;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAwC;;AAExC;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;;AAEA;AACA;AACA;AACA;;AAEA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,mDAAkD;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2HAA0H;AAC1H;AACA;AACA;;AAEA,gCAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4DAA2D;AAC3D;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA,4EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA,8FAA6F;AAC7F;AACA;AACA;AACA,+DAA8D;AAC9D;AACA;AACA;AACA;AACA,oEAAmE;AACnE;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAmC;;AAEnC;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;ACnZA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA;;AAEA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA;;AAEA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA,E;;;;;;ACvEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,4DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,uBAAsB,cAAc;AACpC;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAuG;AACvG,kDAAiD,EAAE;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,wCAAwC;AACvF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gDAA+C,aAAa;AAC5D;;AAEA;AACA;AACA;;AAEA;AACA,qCAAoC;;AAEpC;AACA;;AAEA;AACA,4BAA2B,sBAAsB;AACjD;;AAEA;AACA;AACA,wFAAuF;AACvF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL,EAAC;;AAED,sC;;;;;;AC5JA,gD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAsB;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAqD;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;AC3PA,gD;;;;;;ACAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAsE;AACtE,MAAK;;AAEL;AACA;;AAEA;AACA,wFAAuF;AACvF,MAAK;;AAEL;AACA;AACA;AACA,uEAAsE;AACtE;AACA,EAAC;;AAED,sC;;;;;;AC3BA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB;;AAEjB;;AAEA;AACA,0BAAyB,aAAa;AACtC,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA,4DAA2D,qBAAqB,IAAI;AACpF;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,yEAAwE;AACxE;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAuB;;AAEvB;AACA,0BAAyB;;AAEzB;AACA;AACA,kCAAiC,wBAAwB,EAAE;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,yCAAwC,0CAA0C,EAAE;;AAEpF;AACA,wCAAuC,wDAAwD,EAAE;AACjG,kCAAiC,gCAAgC;AACjE;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA,oCAAmC,cAAc,EAAE;;AAEnD;AACA;AACA;;AAEA,6CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;;AAEA;AACA,kCAAiC,6BAA6B;AAC9D;;AAEA;AACA,4BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,6CAA4C,mBAAmB;AAC/D,kBAAiB;AACjB;AACA;AACA,MAAK;AACL,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC,wBAAwB;AACxD;;AAEA;AACA;;AAEA,gC;;;;;;AC1TA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,4BAA2B,qBAAqB,cAAc,GAAG,EAAE;;AAEnE;AACA;AACA;AACA;AACA,uBAAsB;;AAEtB;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,8BAA6B,qCAAqC,EAAE;;AAEpE;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA,8CAA6C,mBAAmB;AAChE,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACzFD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL,+BAA8B,eAAe;AAC7C,2CAA0C;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,8BAA6B,kDAAkD,EAAE;;AAEjF;AACA;AACA;AACA,MAAK;;AAEL;AACA,wBAAuB;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,yCAAwC,gBAAgB;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;;;;;;AChLA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,4BAA2B,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,aAAa,EAAE,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,uBAAuB,EAAE,SAAS,EAAE;;AAEhJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA0B,0BAA0B;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL,gCAA+B,gCAAgC,EAAE;;AAEjE,kCAAiC,oCAAoC,EAAE;AACvE,mCAAkC,oCAAoC;AACtE,EAAC;;AAED;AACA;AACA;AACA;AACA,yBAAwB,gCAAgC;;AAExD;AACA,yBAAwB,oBAAoB,EAAE;;AAE9C,gCAA+B,cAAc,EAAE;AAC/C,gCAA+B,kDAAkD,EAAE;;AAEnF,kCAAiC,gBAAgB,EAAE;;AAEnD,+BAA8B,cAAc;AAC5C,EAAC;;AAED;AACA;AACA;AACA,gCAA+B,cAAc,EAAE;AAC/C;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA,4BAA2B,aAAa;AACxC,EAAC;;AAED;AACA;;AAEA;AACA,kCAAiC,uCAAuC,EAAE;AAC1E,yCAAwC,wCAAwC,EAAE;AAClF,gCAA+B,gCAAgC,EAAE;;AAEjE,kCAAiC,gBAAgB,EAAE;;AAEnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB,4CAA2C,wDAAwD,EAAE;AACrG,sCAAqC,gCAAgC;AACrE;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,6CAA4C;AAC5C,gEAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;AChMD;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAAyB,eAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;;AAEA;AACA;AACA,wBAAuB;;AAEvB;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;;AAEb;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA","file":"./nestedtypes.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"backbone\"), require(\"underscore\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"backbone\", \"underscore\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Nested\"] = factory(require(\"backbone\"), require(\"underscore\"));\n\telse\n\t\troot[\"Nested\"] = factory(root[\"Backbone\"], root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_6__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ba7a620d0cc3e93ea18b\n **/","// NestedTypes namespace\r\n// =======================\r\n\r\nvar Model      = require( './model' ),\r\n    Collection = require( './collection' ),\r\n    relations  = require( './relations' ),\r\n    Backbone   = require( './backbone+' ),\r\n    attribute  = require( './attribute' );\r\n\r\nrequire( './metatypes' );\r\n\r\nCollection.subsetOf = relations.subsetOf;\r\nModel.from          = relations.from;\r\nModel.Collection    = Collection;\r\n\r\nObject.defineProperty( exports, 'store', require( './store' ) );\r\n\r\nObject.assign( exports, {\r\n    Class     : require( './object+' ),\r\n    error     : require( './errors' ),\r\n    attribute : attribute,\r\n    options   : attribute,\r\n\r\n    value : function( value ){\r\n        return attribute( { value : value } );\r\n    },\r\n\r\n    Collection : Collection,\r\n    Model      : Model,\r\n\r\n    // proxy backbone classes...\r\n    View    : Backbone.View,\r\n    Events  : Backbone.Events,\r\n    Router  : Backbone.Router,\r\n    History : Backbone.History,\r\n\r\n    defaults : function( x ){\r\n        return Model.defaults( x );\r\n    },\r\n\r\n    transaction : function( fun ){\r\n        return function(){\r\n            return this.transaction( fun, this, arguments );\r\n        }\r\n    }\r\n} );\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","var BaseModel   = require( './backbone+' ).Model,\r\n    modelSet    = require( './modelset' ),\r\n    attrOptions = require( './attribute' ),\r\n    error       = require( './errors' ),\r\n    _           = require( 'underscore' ),\r\n    ModelProto  = BaseModel.prototype;\r\n\r\nvar setSingleAttr = modelSet.setSingleAttr,\r\n    setAttrs        = modelSet.setAttrs,\r\n    applyTransform  = modelSet.transform;\r\n\r\nfunction cloneAttrs( attrSpecs, attrs, options ){\r\n    for( var name in attrs ){\r\n        attrs[ name ] = attrSpecs[ name ].clone( attrs[ name ], options );\r\n    }\r\n\r\n    return attrs;\r\n}\r\n\r\nvar Model = BaseModel.extend( {\r\n    triggerWhenChanged : 'change',\r\n\r\n    properties : {\r\n        id : {\r\n            get : function(){\r\n                var name = this.idAttribute;\r\n\r\n                // TODO: get hook doesn't work for idAttribute === 'id'\r\n                return name === 'id' ? this.attributes.id : this[ name ];\r\n            },\r\n\r\n            set : function( value ){\r\n                var name = this.idAttribute;\r\n                setSingleAttr( this, name, value, this.__attributes[ name ] );\r\n            }\r\n        }\r\n    },\r\n\r\n    __attributes : { id : attrOptions( { value : undefined } ).createAttribute( 'id' ) },\r\n    __class      : 'Model',\r\n\r\n    __duringSet : 0,\r\n\r\n    defaults : function(){ return {}; },\r\n\r\n    __begin  : modelSet.__begin,\r\n    __commit : modelSet.__commit,\r\n\r\n    transaction : modelSet.transaction,\r\n\r\n    set : function( a, b, c ){\r\n        switch( typeof a ){\r\n        case 'string' :\r\n            var attrSpec = this.__attributes[ a ];\r\n\r\n            if( attrSpec && !attrSpec.isBackboneType && !c ){\r\n                return setSingleAttr( this, a, b, attrSpec );\r\n            }\r\n\r\n            var attrs = {};\r\n            attrs[ a ] = b;\r\n            return setAttrs( this, attrs, c );\r\n\r\n        case 'object' :\r\n            if( a && Object.getPrototypeOf( a ) === Object.prototype ){\r\n                return setAttrs( this, a, b );\r\n            }\r\n\r\n        default :\r\n            error.argumentIsNotAnObject( this, a );\r\n        }\r\n    },\r\n\r\n    // Return model's value for dot-separated 'deep reference'.\r\n    // Model id and cid are allowed for collection elements.\r\n    // If path is not exist, 'undefined' is returned.\r\n    // model.deepGet( 'a.b.c123.x' )\r\n    deepGet : function( name ){\r\n        var path = name.split( '.' ), value = this;\r\n\r\n        for( var i = 0, l = path.length; value && i < l; i++ ){\r\n            value = value.get ? value.get( path[ i ] ) : value[ path[ i ] ];\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    // Set model's value for dot separated 'deep reference'.\r\n    // If model doesn't exist at some path, create default models\r\n    // if options.nullify is given, assign attributes with nulls\r\n    deepSet : function( name, value, options ){\r\n        var path  = name.split( '.' ),\r\n            l     = path.length - 1,\r\n            model = this,\r\n            attr  = path[ l ];\r\n\r\n        for( var i = 0; i < l; i++ ){\r\n            var current = path[ i ],\r\n                next    = model.get ? model.get( current ) : model[ current ];\r\n\r\n            // Create models in path, if they are not exist.\r\n            if( !next ){\r\n                var attrSpecs = model.__attributes;\r\n\r\n                if( attrSpecs ){\r\n                    // If current object is model, create default attribute\r\n                    var newModel = attrSpecs[ current ].create( options );\r\n\r\n                    // If created object is model, nullify attributes when requested\r\n                    if( options && options.nullify && newModel.__attributes ){\r\n                        var nulls = new newModel.Attributes( {} );\r\n                        for( var key in nulls ){\r\n                            nulls[ key ] = null;\r\n                        }\r\n                        newModel.set( nulls );\r\n                    }\r\n\r\n                    model[ current ] = next = newModel;\r\n                }\r\n                else{\r\n                    return;\r\n                } // silently fail in other case\r\n            }\r\n            model = next;\r\n        }\r\n\r\n        return model.set ? model.set( attr, value, options ) : model[ attr ] = value;\r\n    },\r\n\r\n    constructor : function( attributes, opts ){\r\n        var attrSpecs = this.__attributes,\r\n            attrs     = attributes || {},\r\n            options   = opts || {};\r\n\r\n        this.cid = _.uniqueId( 'c' );\r\n        this.attributes = {};\r\n        if( options.collection ){\r\n            this.collection = options.collection;\r\n        }\r\n        if( options.parse ){\r\n            attrs = this.parse( attrs, options ) || {};\r\n        }\r\n\r\n        if( typeof attrs !== 'object' || Object.getPrototypeOf( attrs ) !== Object.prototype ){\r\n            error.argumentIsNotAnObject( this, attrs );\r\n            attrs = {};\r\n        }\r\n\r\n        attrs = options.deep ?\r\n                cloneAttrs( attrSpecs, new this.Attributes( attrs ), options ) :\r\n                this.defaults( attrs, options );\r\n\r\n        // Execute attributes transform function instead of this.set\r\n        applyTransform( this, attrs, attrSpecs, options );\r\n\r\n        this.attributes = attrs;\r\n        this.changed = {};\r\n        this.initialize.apply( this, arguments );\r\n    },\r\n    // override get to invoke native getter...\r\n    get         : function( name ){ return this[ name ]; },\r\n\r\n    // override clone to pass options to constructor\r\n    clone : function( options ){\r\n        return new this.constructor( this.attributes, options );\r\n    },\r\n\r\n    // Create deep copy for all nested objects...\r\n    deepClone : function(){ return this.clone( { deep : true } ); },\r\n\r\n    // Support for nested models and objects.\r\n    // Apply toJSON recursively to produce correct JSON.\r\n    toJSON : function(){\r\n        var res   = {},\r\n            attrs = this.attributes, attrSpecs = this.__attributes;\r\n\r\n        for( var key in attrs ){\r\n            var value  = attrs[ key ], attrSpec = attrSpecs[ key ],\r\n                toJSON = attrSpec && attrSpec.toJSON;\r\n\r\n            if( toJSON ){\r\n                res[ key ] = toJSON.call( this, value, key );\r\n            }\r\n        }\r\n\r\n        return res;\r\n    },\r\n\r\n    parse  : function( resp ){ return this._parse( resp ); },\r\n    _parse : _.identity,\r\n\r\n    isValid : function( options ){\r\n        // todo: need to do something smart with validation logic\r\n        // something declarative on attributes level, may be\r\n        return ModelProto.isValid.call( this, options ) && _.every( this.attributes, function( attr ){\r\n                if( attr && attr.isValid ){\r\n                    return attr.isValid( options );\r\n                }\r\n\r\n                return attr instanceof Date ? !_.isNaN( attr.getTime() ) : !_.isNaN( attr );\r\n            } );\r\n    },\r\n\r\n    _ : _ // add underscore to be accessible in templates\r\n}, {\r\n    // shorthand for inline nested model definitions\r\n    defaults : function( attrs ){ return this.extend( { defaults : attrs } ); },\r\n\r\n    // extend Model and its Collection\r\n    extend : function( protoProps, staticProps ){\r\n        var This = Object.extend.call( this );\r\n        This.Collection = this.Collection.extend();\r\n        return protoProps ? This.define( protoProps, staticProps ) : This;\r\n    },\r\n\r\n    // define Model and its Collection. All the magic starts here.\r\n    define : function( protoProps, staticProps ){\r\n        var Base = Object.getPrototypeOf( this.prototype ).constructor,\r\n            spec = createDefinition( protoProps, Base ),\r\n            This = this;\r\n\r\n        Object.extend.Class.define.call( This, spec, staticProps );\r\n\r\n        // define Collection\r\n        var collectionSpec = { model : This };\r\n        spec.urlRoot && ( collectionSpec.url = spec.urlRoot );\r\n        This.Collection.define( _.defaults( protoProps.collection || {}, collectionSpec ) );\r\n\r\n        return This;\r\n    }\r\n} );\r\n\r\n// Create model definition from protoProps spec.\r\nfunction createDefinition( protoProps, Base ){\r\n    var defaults           = protoProps.defaults || protoProps.attributes || {},\r\n        defaultsAsFunction = typeof defaults == 'function' && defaults,\r\n        baseAttrSpecs      = Base.prototype.__attributes;\r\n\r\n    // Support for legacy backbone defaults as functions.\r\n    if( defaultsAsFunction ){\r\n        defaults = defaults();\r\n    }\r\n\r\n    var attrSpecs = Object.transform( {}, defaults, attrOptions.create );\r\n\r\n    // Create attribute for idAttribute, if it's not declared explicitly\r\n    var idAttribute = protoProps.idAttribute;\r\n    if( idAttribute && !attrSpecs[ idAttribute ] ){\r\n        attrSpecs[ idAttribute ] = attrOptions( { value : undefined } ).createAttribute( idAttribute );\r\n    }\r\n\r\n    // Prevent conflict with backbone model's 'id' property\r\n    if( attrSpecs[ 'id' ] ){\r\n        attrSpecs[ 'id' ].createPropertySpec = false;\r\n    }\r\n\r\n    var allAttrSpecs = _.defaults( {}, attrSpecs, baseAttrSpecs ),\r\n        Attributes   = createCloneCtor( allAttrSpecs );\r\n\r\n    return _.extend( _.omit( protoProps, 'collection', 'attributes' ), {\r\n        __attributes : new Attributes( allAttrSpecs ),\r\n        _parse       : create_parse( allAttrSpecs, attrSpecs ) || Base.prototype._parse,\r\n        defaults     : defaultsAsFunction || createDefaults( allAttrSpecs ),\r\n        properties   : createAttrsNativeProps( protoProps.properties, attrSpecs ),\r\n        Attributes   : Attributes\r\n    } );\r\n}\r\n\r\n// Create attributes 'parse' option function only if local 'parse' options present.\r\n// Otherwise return null.\r\nfunction create_parse( allAttrSpecs, attrSpecs ){\r\n    var statements = [ 'var a = this.__attributes;' ],\r\n        create = false;\r\n\r\n    for( var name in allAttrSpecs ){\r\n        // Is there any 'parse' option in local model definition?\r\n        if( attrSpecs[ name ] && attrSpecs[ name ].parse ) create = true;\r\n\r\n        // Add statement for each attribute with 'parse' option.\r\n        if( allAttrSpecs[ name ].parse ){\r\n            var s = 'if(\"' + name + '\" in r) r.' + name + '=a.' + name + '.parse.call(this,r.' + name + ',\"' + name + '\");';\r\n            statements.push( s );\r\n        }\r\n    }\r\n\r\n    statements.push( 'return r;' );\r\n\r\n    return create ? new Function( 'r', statements.join( '' ) ) : null;\r\n}\r\n\r\n// Create constructor for efficient attributes clone operation.\r\nfunction createCloneCtor( attrSpecs ){\r\n    var statements = [];\r\n\r\n    for( var name in attrSpecs ){\r\n        statements.push( \"this.\" + name + \"=x.\" + name + \";\" );\r\n    }\r\n\r\n    var Attributes = new Function( \"x\", statements.join( '' ) );\r\n\r\n    // attributes hash must look like vanilla object, otherwise Model.set will trigger an exception\r\n    Attributes.prototype = Object.prototype;\r\n\r\n    return Attributes;\r\n}\r\n\r\n// Check if value is valid JSON.\r\nfunction isValidJSON( value ){\r\n    if( value === null ){\r\n        return true;\r\n    }\r\n\r\n    switch( typeof value ){\r\n    case 'number' :\r\n    case 'string' :\r\n    case 'boolean' :\r\n        return true;\r\n\r\n    case 'object':\r\n        var proto = Object.getPrototypeOf( value );\r\n\r\n        if( proto === Object.prototype || proto === Array.prototype ){\r\n            return _.every( value, isValidJSON );\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Create optimized model.defaults( attrs, options ) function\r\nfunction createDefaults( attrSpecs ){\r\n    var statements = [], init = {}, refs = {};\r\n\r\n    // Compile optimized constructor function for efficient deep copy of JSON literals in defaults.\r\n    _.each( attrSpecs, function( attrSpec, name ){\r\n        if( attrSpec.value === undefined && attrSpec.type ){\r\n            // if type with no value is given, create an empty object\r\n            init[ name ] = attrSpec;\r\n            statements.push( 'this.' + name + '=i.' + name + '.create( o );' );\r\n        }\r\n        else{\r\n            // If value is given, type casting logic will do the job later, converting value to the proper type.\r\n            if( isValidJSON( attrSpec.value ) ){\r\n                // JSON literals must be deep copied.\r\n                statements.push( 'this.' + name + '=' + JSON.stringify( attrSpec.value ) + ';' );\r\n            }\r\n            else if( attrSpec.value === undefined ){\r\n                // handle undefined value separately. Usual case for model ids.\r\n                statements.push( 'this.' + name + '=undefined;' );\r\n            }\r\n            else{\r\n                // otherwise, copy value by reference.\r\n                refs[ name ] = attrSpec.value;\r\n                statements.push( 'this.' + name + '=r.' + name + ';' );\r\n            }\r\n\r\n        }\r\n    } );\r\n\r\n    var Defaults = new Function( 'r', 'i', 'o', statements.join( '' ) );\r\n    Defaults.prototype = Object.prototype;\r\n\r\n    // Create model.defaults( attrs, options ) function\r\n    // 'attrs' will override default values, options will be passed to nested backbone types\r\n    return function( attrs, options ){\r\n        var opts = options, name;\r\n\r\n        // 'collection' and 'parse' options must not be passed down to default nested models and collections\r\n        if( options && ( options.collection || options.parse ) ){\r\n            opts = {};\r\n            for( name in options ){\r\n                if( name !== 'collection' && name !== 'parse' ){\r\n                    opts[ name ] = options[ name ];\r\n                }\r\n            }\r\n        }\r\n\r\n        var defaults = new Defaults( refs, init, opts );\r\n\r\n        // assign attrs, overriding defaults\r\n        for( var name in attrs ){\r\n            defaults[ name ] = attrs[ name ];\r\n        }\r\n\r\n        return defaults;\r\n    }\r\n}\r\n\r\n// Create native properties for model's attributes\r\nfunction createAttrsNativeProps( properties, attrSpecs ){\r\n    if( properties === false ){\r\n        return {};\r\n    }\r\n\r\n    properties || ( properties = {} );\r\n\r\n    return Object.transform( properties, attrSpecs, function( attrSpec, name ){\r\n        if( !properties[ name ] && attrSpec.createPropertySpec ){\r\n            return attrSpec.createPropertySpec();\r\n        }\r\n    } );\r\n}\r\n\r\nmodule.exports = Model;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/model.js\n ** module id = 1\n ** module chunks = 0\n **/","/* Backbone core extensions: bug fixes and optimizations\r\n    - Use Object+ for all backbone objects\r\n    - Fix for Events.listenTo to support message maps\r\n    - optimized trigger functions\r\n\r\n * (c) Vlad Balin & Volicon, 2015\r\n * ------------------------------------------------------------- */\r\n\r\nvar Class = require( './object+' ),\r\n    Backbone = require( 'backbone' );\r\n\r\nmodule.exports = Backbone;\r\n\r\n// Workaround for backbone 1.2.0 listenTo event maps bug\r\nvar Events = Backbone.Events,\r\n    bbListenTo = Events.listenTo;\r\n\r\nEvents.listenTo = function( obj, events ){\r\n    if( typeof events === 'object' ){\r\n        for( var event in events ) bbListenTo.call( this, obj, event, events[ event ] );\r\n        return this;\r\n    }\r\n\r\n    return bbListenTo.apply( this, arguments );\r\n};\r\n\r\n// Update Backbone objects to use event patches and Object+\r\n[ 'Model', 'Collection', 'View', 'Router', 'History' ].forEach( function( name ){\r\n    var Type = Backbone[ name ];\r\n    Type.prototype.listenTo = Events.listenTo;\r\n    Object.extend.attach( Type );\r\n});\r\n\r\n// Make Object.extend classes capable of sending and receiving Backbone Events...\r\nObject.assign( Class.prototype, Events );\r\n\r\n// So hard to believe :) You won't. Optimized JIT-friendly event trigger functions to be used from model.set\r\n// Two specialized functions for event triggering...\r\nEvents.trigger2 = function( self, name, a, b ){\r\n    var _events = self._events;\r\n    if( _events ){\r\n        _fireEvent2( _events[ name ], a, b );\r\n        _fireEvent3( _events.all, name, a, b );\r\n    }\r\n};\r\n\r\nEvents.trigger3 = function( self, name, a, b, c ){\r\n    var _events = self._events;\r\n    if( _events ){\r\n        _fireEvent3( _events[ name ], a, b, c );\r\n        _fireEvent4( _events.all, name, a, b, c );\r\n    }\r\n};\r\n\r\n// ...and specialized functions with triggering loops. Crappy JS JIT loves these small functions and code duplication.\r\nfunction _fireEvent2( events, a, b ){\r\n    if( events )\r\n        for( var i = 0, l = events.length, ev; i < l; i ++ )\r\n            (ev = events[i]).callback.call(ev.ctx, a, b);\r\n}\r\n\r\nfunction _fireEvent3( events, a, b, c ){\r\n    if( events )\r\n        for( var i = 0, l = events.length, ev; i < l; i ++ )\r\n            (ev = events[i]).callback.call(ev.ctx, a, b, c);\r\n}\r\n\r\nfunction _fireEvent4( events, a, b, c, d ){\r\n    if( events )\r\n        for( var i = 0, l = events.length, ev; i < l; i ++ )\r\n            (ev = events[i]).callback.call(ev.ctx, a, b, c, d);\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/backbone+.js\n ** module id = 2\n ** module chunks = 0\n **/","/* Object extensions: backbone-style OO functions and helpers...\r\n * (c) Vlad Balin & Volicon, 2015\r\n * ------------------------------------------------------------- */\r\n\r\n(function( spec ){\r\n    for( var name in spec ){\r\n        Object[ name ] || Object.defineProperty( Object, name, {\r\n            enumerable   : false,\r\n            configurable : true,\r\n            writable     : true,\r\n            value        : spec[ name ]\r\n        } );\r\n    }\r\n})( {\r\n    // Object.assign polyfill from MDN.\r\n    assign : function( target, firstSource ){\r\n        if( target == null ){\r\n            throw new TypeError( 'Cannot convert first argument to object' );\r\n        }\r\n\r\n        var to = Object( target );\r\n        for( var i = 1; i < arguments.length; i++ ){\r\n            var nextSource = arguments[ i ];\r\n            if( nextSource == null ){\r\n                continue;\r\n            }\r\n\r\n            var keysArray = Object.keys( Object( nextSource ) );\r\n            for( var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++ ){\r\n                var nextKey = keysArray[ nextIndex ];\r\n                var desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );\r\n                if( desc !== void 0 && desc.enumerable ){\r\n                    to[ nextKey ] = nextSource[ nextKey ];\r\n                }\r\n            }\r\n        }\r\n        return to;\r\n    },\r\n\r\n    // Object.transform function, similar to _.mapObject\r\n    transform : function( dest, source, fun, context ){\r\n        for( var name in source ){\r\n            if( source.hasOwnProperty( name ) ){\r\n                var value = fun.call( context, source[ name ], name );\r\n                typeof value === 'undefined' || ( dest[ name ] = value );\r\n            }\r\n        }\r\n\r\n        return dest;\r\n    },\r\n\r\n    // get property descriptor looking through all prototype chain\r\n    getPropertyDescriptor : function( obj, prop ){\r\n        for( var desc; !desc && obj; obj = Object.getPrototypeOf( obj ) ){\r\n            desc = Object.getOwnPropertyDescriptor( obj, prop );\r\n        }\r\n\r\n        return desc;\r\n    },\r\n\r\n    // extend function in the fashion of Backbone, with extended features required by NestedTypes\r\n    // - supports native properties definitions\r\n    // - supports forward declarations\r\n    // - warn in case if base class method is overriden with value. It's popular mistake when working with Backbone.\r\n    extend : (function(){\r\n        var error = {\r\n            overrideMethodWithValue : function( Ctor, name, value ){\r\n                console.warn( '[Type Warning] Base class method overriden with value in Object.extend({ ' + name +\r\n                              ' : ' + value + ' }); Object =', Ctor.prototype );\r\n            }\r\n        };\r\n\r\n        function Class(){\r\n            this.initialize.apply( this, arguments );\r\n        }\r\n\r\n        // Backbone-style extend with native properties and late definition support\r\n        function extend( protoProps, staticProps ){\r\n            var Parent = this === Object ? Class : this,\r\n                Child;\r\n\r\n            if( typeof protoProps === 'function' ){\r\n                Child = protoProps;\r\n                protoProps = null;\r\n            }\r\n            else if( protoProps && protoProps.hasOwnProperty( 'constructor' ) ){\r\n                Child = protoProps.constructor;\r\n            }\r\n            else{\r\n                Child = function Constructor(){ return Parent.apply( this, arguments ); };\r\n            }\r\n\r\n            Object.assign( Child, Parent );\r\n\r\n            Child.prototype = Object.create( Parent.prototype );\r\n            Child.prototype.constructor = Child;\r\n            Child.__super__ = Parent.prototype;\r\n\r\n            protoProps && Child.define( protoProps, staticProps );\r\n\r\n            return Child;\r\n        }\r\n\r\n        function warnOnError( value, name ){\r\n            var prop = Object.getPropertyDescriptor( this.prototype, name );\r\n\r\n            if( prop ){\r\n                var baseIsFunction  = typeof prop.value === 'function',\r\n                    valueIsFunction = typeof value === 'function';\r\n\r\n                if( baseIsFunction && !valueIsFunction ){\r\n                    error.overrideMethodWithValue( this, name, prop );\r\n                }\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        function preparePropSpec( spec, name ){\r\n            var prop = Object.getPropertyDescriptor( this.prototype, name );\r\n\r\n            if( prop && typeof prop.value === 'function' ){\r\n                error.overrideMethodWithValue( this, name, prop );\r\n            }\r\n\r\n            return spec instanceof Function ? { get : spec } : spec;\r\n        }\r\n\r\n        function define( protoProps, staticProps ){\r\n            Object.transform( this.prototype, protoProps, warnOnError, this );\r\n            Object.transform( this, staticProps, warnOnError, this );\r\n\r\n            protoProps && Object.defineProperties( this.prototype,\r\n                Object.transform( {}, protoProps.properties, preparePropSpec, this ) );\r\n\r\n            return this;\r\n        }\r\n\r\n        extend.attach = function(){\r\n            for( var i = 0; i < arguments.length; i++ ){\r\n                var Ctor = arguments[ i ];\r\n\r\n                Ctor.extend = extend;\r\n                Ctor.define = define;\r\n                Ctor.prototype.initialize || ( Ctor.prototype.initialize = function(){} );\r\n            }\r\n        };\r\n\r\n        extend.attach( Class );\r\n        extend.Class = Class;\r\n        extend.error = error;\r\n\r\n        return extend;\r\n    })()\r\n} );\r\n\r\nmodule.exports = Object.extend.Class;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/object+.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"commonjs\":\"backbone\",\"commonjs2\":\"backbone\",\"amd\":\"backbone\",\"root\":\"Backbone\"}\n ** module id = 4\n ** module chunks = 0\n **/","// Optimized Model.set functions\r\n//---------------------------------\r\n/*\r\n Does two main things:\r\n 1) Invoke model-specific constructor for attributes cloning. It improves performance on large model updates.\r\n 2) Invoke attribute-specific comparison function. Improves performance for everything, especially nested stuff.\r\n\r\n attrSpec is required to provide two methods:\r\n transform( value, options, model, name ) -> value\r\n to transform value before assignment\r\n\r\n isChanged( value1, value2 ) -> bool\r\n to detect whenever attribute must be assigned and counted as changed\r\n\r\n Model is required to implement Attributes constructor for attributes cloning.\r\n */\r\n\r\n// Special case set: used from model's native properties.\r\n// Single attribute change, no options, _no_ _nested_ _changes_ detection on deep update.\r\n// 1) Code is stripped for this special case\r\n// 2) attribute-specific transform function invoked internally\r\n\r\nvar _        = require( 'underscore' ),\r\n    Events   = require( './backbone+' ).Events,\r\n    error    = require( './errors' ),\r\n    trigger2 = Events.trigger2,\r\n    trigger3 = Events.trigger3;\r\n\r\nmodule.exports = {\r\n    isChanged     : genericIsChanged,\r\n    setSingleAttr : setSingleAttr,\r\n    setAttrs      : setAttrs,\r\n    transaction   : transaction,\r\n    transform     : applyTransform,\r\n    __begin       : __begin,\r\n    __commit      : __commit\r\n};\r\n\r\nfunction genericIsChanged( a, b ){\r\n    return !( a === b || ( a && b && typeof a == 'object' && typeof b == 'object' && _.isEqual( a, b ) ) );\r\n}\r\n\r\nfunction setSingleAttr( model, key, value, attrSpec ){\r\n    'use strict';\r\n    var changing = model._changing,\r\n        current  = model.attributes;\r\n\r\n    model._changing = true;\r\n\r\n    if( !changing ){\r\n        model._previousAttributes = new model.Attributes( current );\r\n        model.changed             = {};\r\n    }\r\n\r\n    var prev      = model._previousAttributes,\r\n        options   = {},\r\n        val       = attrSpec.transform( value, options, model, key ),\r\n        isChanged = attrSpec.isChanged;\r\n\r\n    isChanged( prev[ key ], val ) ? model.changed[ key ] = val : delete model.changed[ key ];\r\n\r\n    if( isChanged( current[ key ], val ) ){\r\n        current[ key ] = val;\r\n        model._pending = options;\r\n        trigger3( model, 'change:' + key, model, val, options );\r\n    }\r\n\r\n    if( changing ){\r\n        return model;\r\n    }\r\n\r\n    while( model._pending ){\r\n        options        = model._pending;\r\n        model._pending = false;\r\n        trigger2( model, 'change', model, options );\r\n    }\r\n\r\n    model._pending  = false;\r\n    model._changing = false;\r\n    return model;\r\n}\r\n\r\n\r\n// call a_fun with a_args inside of set transaction.\r\n// model.set inside of a_fun will trigger change:attr\r\n// but only single 'change' will be triggered at the end of transaction\r\n// transactions can be nested\r\nfunction transaction( a_fun, context, args ){\r\n    var notChanging = !this._changing,\r\n        options  = {};\r\n\r\n    this._changing = true;\r\n\r\n\r\n    if( notChanging ){\r\n        this._previousAttributes = new this.Attributes( this.attributes );\r\n        this.changed             = {};\r\n    }\r\n\r\n    this.__begin();\r\n    var res = a_fun.apply( context || this, args );\r\n    this.__commit();\r\n\r\n    if( notChanging ){\r\n        while( this._pending ){\r\n            options       = this._pending;\r\n            this._pending = false;\r\n            trigger2( this, 'change', this, options );\r\n        }\r\n\r\n        this._pending  = false;\r\n        this._changing = false;\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\n// General case set: used for multiple and nested model/collection attributes.\r\n// Does _not_ invoke attribute transform! It must be done at the the top level,\r\n// due to the problems with current nested changes detection algorithm. See 'setAttrs' function below.\r\nfunction bbSetAttrs( model, attrs, opts ){\r\n    'use strict';\r\n    var options = opts || {};\r\n\r\n    // Run validation.\r\n    if( !model._validate( attrs, options ) ){\r\n        return false;\r\n    }\r\n\r\n    // Extract attributes and options.\r\n    var unset     = options.unset,\r\n        silent    = options.silent,\r\n        changes   = [],\r\n        changing  = model._changing,\r\n        current   = model.attributes,\r\n        attrSpecs = model.__attributes;\r\n\r\n    model._changing = true;\r\n\r\n    if( !changing ){\r\n        model._previousAttributes = new model.Attributes( current );\r\n        model.changed             = {};\r\n    }\r\n\r\n    var prev = model._previousAttributes;\r\n\r\n    // For each `set` attribute, update or delete the current value.\r\n    for( var attr in attrs ){\r\n        var attrSpec  = attrSpecs[ attr ],\r\n            isChanged = attrSpec ? attrSpec.isChanged : genericIsChanged,\r\n            val       = attrs[ attr ];\r\n\r\n        if( isChanged( current[ attr ], val ) ){\r\n            changes.push( attr );\r\n        }\r\n\r\n        if( isChanged( prev[ attr ], val ) ){\r\n            model.changed[ attr ] = val;\r\n        }\r\n        else{\r\n            delete model.changed[ attr ];\r\n        }\r\n\r\n        unset ? delete current[ attr ] : current[ attr ] = val;\r\n    }\r\n\r\n    // Trigger all relevant attribute changes.\r\n    if( !silent ){\r\n        if( changes.length ){\r\n            model._pending = options;\r\n        }\r\n        for( var i = 0, l = changes.length; i < l; i++ ){\r\n            attr = changes[ i ];\r\n            trigger3( model, 'change:' + attr, model, current[ attr ], options );\r\n        }\r\n    }\r\n\r\n    // You might be wondering why there's a `while` loop here. Changes can\r\n    // be recursively nested within `\"change\"` events.\r\n    if( changing ){\r\n        return model;\r\n    }\r\n    if( !silent ){\r\n        while( model._pending ){\r\n            options        = model._pending;\r\n            model._pending = false;\r\n            trigger2( model, 'change', model, options );\r\n        }\r\n    }\r\n\r\n    model._pending  = false;\r\n    model._changing = false;\r\n\r\n    return model;\r\n}\r\n\r\n// Optimized Backbone Core functions\r\n// =================================\r\n// Deep set model attributes, catching nested attributes changes\r\nfunction setAttrs( model, attrs, options ){\r\n    model.__begin();\r\n\r\n    applyTransform( model, attrs, model.__attributes, options );\r\n\r\n    model.__commit( attrs, options );\r\n\r\n    return model;\r\n}\r\n\r\n// transform attributes hash\r\nfunction applyTransform( model, attrs, attrSpecs, options ){\r\n    for( var name in attrs ){\r\n        var attrSpec = attrSpecs[ name ], value = attrs[ name ];\r\n        if( attrSpec ){\r\n            attrs[ name ] = attrSpec.transform( value, options, model, name );\r\n        }\r\n        else{\r\n            error.unknownAttribute( model, name, value );\r\n        }\r\n    }\r\n}\r\n\r\nfunction __begin(){\r\n    this.__duringSet++ || ( this.__nestedChanges = {} );\r\n}\r\n\r\nfunction __commit( a_attrs, options ){\r\n    var attrs = a_attrs;\r\n\r\n    if( !--this.__duringSet ){\r\n        var nestedChanges = this.__nestedChanges,\r\n            attributes    = this.attributes;\r\n\r\n        attrs || ( attrs = {} );\r\n\r\n        // Catch nested changes.\r\n        for( var name in nestedChanges ){\r\n            var value = name in attrs ? attrs[ name ] : attrs[ name ] = nestedChanges[ name ];\r\n\r\n            if( value === attributes[ name ] ){\r\n                // patch attributes to force change:name event\r\n                attributes[ name ] = null;\r\n            }\r\n        }\r\n\r\n        this.__nestedChanges = {};\r\n    }\r\n\r\n    if( attrs ){\r\n        bbSetAttrs( this, attrs, options );\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modelset.js\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"commonjs\":\"underscore\",\"commonjs2\":\"underscore\",\"amd\":\"underscore\",\"root\":\"_\"}\n ** module id = 6\n ** module chunks = 0\n **/","require( './object+' );\r\n\r\nfunction format( value ){\r\n    return typeof value === 'string' ? '\"' + value + '\"' : value;\r\n}\r\n\r\nObject.assign( Object.extend.error, {\r\n    argumentIsNotAnObject : function( context, value ){\r\n        //throw new TypeError( 'Attribute hash is not an object in ' + context.__class + '.set(', value, ')' );\r\n        console.error( '[Type Error] Attribute hash is not an object in ' +\r\n                       context.__class + '.set(', format( value ), '); this =', context );\r\n    },\r\n\r\n    unknownAttribute : function( context, name, value ){\r\n        if( context.suppressTypeErrors ) return;\r\n\r\n        console.warn( '[Type Error] Attribute has no default value in ' +\r\n                        context.__class + '.set( \"' + name + '\",', format( value ), '); this =', context );\r\n    },\r\n\r\n    wrongCollectionSetArg : function( context, value ){\r\n        //throw new TypeError( 'Wrong argument type in ' + context.__class + '.set(' + value + ')' );\r\n        console.error( '[Type Error] Wrong argument type in ' +\r\n                       context.__class + '.set(', format( value ), '); this =', context );\r\n    }\r\n});\r\n\r\nmodule.exports = Object.extend.error;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/errors.js\n ** module id = 7\n ** module chunks = 0\n **/","// Options wrapper for chained and safe type specs...\r\n// --------------------------------------------------\r\nrequire( './object+' );\r\n\r\nvar trigger3         = require( './backbone+' ).Events.trigger3,\r\n    modelSet         = require( './modelset' ),\r\n    genericIsChanged = modelSet.isChanged,\r\n    setSingleAttr    = modelSet.setSingleAttr;\r\n\r\nvar primitiveTypes = {\r\n    string  : String,\r\n    number  : Number,\r\n    boolean : Boolean\r\n};\r\n\r\n// list of simple accessor methods available in options\r\nvar availableOptions = [ 'triggerWhenChanged', 'changeEvents', 'parse', 'clone', 'toJSON', 'value', 'cast', 'create', 'name', 'value',\r\n                         'type' ];\r\n\r\nvar Options = Object.extend( {\r\n    _options : {}, // attribute options\r\n\r\n    Attribute : null, // default attribute spec when no type is given, is set to Attribute below\r\n\r\n    properties : {\r\n        has : function(){ return this; }\r\n    },\r\n\r\n    constructor : function( spec ){\r\n        // special option used to guess types of primitive values and to distinguish value from type\r\n        if( 'typeOrValue' in spec ){\r\n            var typeOrValue   = spec.typeOrValue,\r\n                primitiveType = primitiveTypes[ typeof typeOrValue ];\r\n\r\n            if( primitiveType ){\r\n                spec = { type : primitiveType, value : typeOrValue };\r\n            }\r\n            else{\r\n                spec = typeof typeOrValue == 'function' ? { type : typeOrValue } : { value : typeOrValue };\r\n            }\r\n        }\r\n\r\n        this._options = {};\r\n        this.options( spec );\r\n    },\r\n\r\n    // get hooks stored as an array\r\n    get : function( getter ){\r\n        var options = this._options;\r\n        options.get = options.get ? options.get.unshift( getter ) : [ getter ];\r\n        return this;\r\n    },\r\n\r\n    // set hooks stored as an array\r\n    set : function( setter ){\r\n        var options = this._options;\r\n        options.set = options.set ? options.set.push( setter ) : [ setter ];\r\n        return this;\r\n    },\r\n\r\n    // events must be merged\r\n    events : function( events ){\r\n        this._options.events = Object.assign( this._options.events || {}, events );\r\n        return this;\r\n    },\r\n\r\n    // options must be merged using rules for individual accessors\r\n    options : function( options ){\r\n        for( var i in options ){\r\n            this[ i ]( options[ i ] );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    // construct attribute with a given name and proper type.\r\n    createAttribute : function( name ){\r\n        var options = this._options,\r\n            Type    = options.type ? options.type.Attribute : this.Attribute;\r\n\r\n        if( options.changeEvents ) options.triggerWhenChanged = options.changeEvents;\r\n\r\n        return new Type( name, options );\r\n    }\r\n} );\r\n\r\navailableOptions.forEach( function( name ){\r\n    Options.prototype[ name ] = function( value ){\r\n        this._options[ name ] = value;\r\n        return this;\r\n    };\r\n} );\r\n\r\nfunction chainHooks( array ){\r\n    var l = array.length;\r\n\r\n    return l === 1 ? array[ 0 ] : function( value, name ){\r\n        var res = value;\r\n        for( var i = 0; i < l; i++ ){\r\n            res = array[ i ].call( this, res, name );\r\n        }\r\n        return res;\r\n    };\r\n}\r\n\r\nvar transform = {\r\n    hookAndCast : function( val, options, model, name ){\r\n        var value = this.cast( val, options, model, name ),\r\n            prev  = model.attributes[ name ];\r\n\r\n        if( this.isChanged( value, prev ) ){\r\n            value = this.set.call( model, value, name );\r\n            return value === undefined ? prev : this.cast( value, options, model );\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    hook : function( value, options, model, name ){\r\n        var prev = model.attributes[ name ];\r\n\r\n        if( this.isChanged( value, prev ) ){\r\n            var changed = this.set.call( model, value, name );\r\n            return changed === undefined ? prev : changed;\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    delegateAndMore : function( val, options, model, attr ){\r\n        return this.delegateEvents( this._transform( val, options, model, attr ), options, model, attr );\r\n    }\r\n};\r\n\r\n// Base class for Attribute metatype\r\n// ---------------------------------\r\n\r\nvar Attribute = Object.extend( {\r\n    name  : null,\r\n    type  : null,\r\n    value : undefined,\r\n\r\n    // cast function\r\n    // may be overriden in subclass\r\n    cast : null, // function( value, options, model ),\r\n\r\n    // get and set hooks...\r\n    get : null,\r\n    set : null,\r\n\r\n    // user events\r\n    events : null, // { event : handler, ... }\r\n\r\n    // system events\r\n    __events : null, // { event : handler, ... }\r\n\r\n    // create empty object passing backbone options to constructor...\r\n    // must be overriden for backbone types only\r\n    create : function( options ){ return new this.type(); },\r\n\r\n    // optimized general purpose isEqual function for typeless attributes\r\n    // must be overriden in subclass\r\n    isChanged : genericIsChanged,\r\n\r\n    // generic clone function for typeless attributes\r\n    // Must be overriden in sublass\r\n    clone : function( value, options ){\r\n        if( value && typeof value === 'object' ){\r\n            var proto = Object.getPrototypeOf( value );\r\n\r\n            if( proto.clone ){\r\n                // delegate to object's clone if it exist\r\n                return value.clone( options );\r\n            }\r\n\r\n            if( options && options.deep && proto === Object.prototype || proto === Array.prototype ){\r\n                // attempt to deep copy raw objects, assuming they are JSON\r\n                return JSON.parse( JSON.stringify( value ) );\r\n            }\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    toJSON : function( value, key ){\r\n        return value && value.toJSON ? value.toJSON() : value;\r\n    },\r\n\r\n    // must be overriden for backbone types...\r\n    createPropertySpec : function(){\r\n        return (function( self, name, get ){\r\n            return {\r\n                // call to optimized set function for single argument. Doesn't work for backbone types.\r\n                set : function( value ){ setSingleAttr( this, name, value, self ); },\r\n\r\n                // attach get hook to the getter function, if present\r\n                get : get ? function(){ return get.call( this, this.attributes[ name ], name ); } :\r\n                      function(){ return this.attributes[ name ]; }\r\n            }\r\n        })( this, this.name, this.get );\r\n    },\r\n\r\n    // automatically generated optimized transform function\r\n    // do not touch.\r\n    _transform : null,\r\n    transform  : function( value ){ return value; },\r\n\r\n    // delegate user and system events on attribute transform\r\n    delegateEvents : function( value, options, model, name ){\r\n        var prev = model.attributes[ name ];\r\n\r\n        if( this.isChanged( prev, value ) ){ //should be changed only when attr is really replaced.\r\n            prev && prev.trigger && model.stopListening( prev );\r\n\r\n            if( value && value.trigger ){\r\n                if( this.events ){\r\n                    model.listenTo( value, this.events );\r\n                }\r\n                if( this.__events ){\r\n                    model.listenTo( value, this.__events );\r\n                }\r\n            }\r\n\r\n            trigger3( model, 'replace:' + name, model, value, prev );\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    constructor : function( name, spec ){\r\n        this.name = name;\r\n\r\n        Object.transform( this, spec, function( value, name ){\r\n            if( name === 'events' && this.events ){\r\n                return Object.assign( this.events, value );\r\n            }\r\n\r\n            if( name === 'get' ){\r\n                if( this.get ){\r\n                    value.unshift( this.get );\r\n                }\r\n                return chainHooks( value );\r\n            }\r\n\r\n            if( name === 'set' ){\r\n                if( this.set ){\r\n                    value.push( this.set );\r\n                }\r\n                return chainHooks( value );\r\n            }\r\n\r\n            return value;\r\n        }, this );\r\n\r\n        this.initialize( spec );\r\n\r\n        // assemble optimized transform function...\r\n        if( this.cast ){\r\n            this.transform = this._transform = this.cast;\r\n        }\r\n        if( this.set ){\r\n            this.transform = this._transform = this.cast ? transform.hookAndCast : transform.hook;\r\n        }\r\n        if( this.events || this.__events ){\r\n            this.transform =\r\n                this._transform ? transform.delegateAndMore : this.delegateEvents;\r\n        }\r\n    }\r\n}, {\r\n    attach : (function(){\r\n        function options( spec ){\r\n            spec || ( spec = {} );\r\n            spec.type || ( spec.type = this );\r\n            return new Options( spec );\r\n        }\r\n\r\n        function value( value ){\r\n            return new Options( { type : this, value : value } );\r\n        }\r\n\r\n        return function(){\r\n            for( var i = 0; i < arguments.length; i++ ){\r\n                var Type = arguments[ i ];\r\n                Type.attribute = Type.options = options;\r\n                Type.value = value;\r\n                Type.Attribute = this;\r\n                Object.defineProperty( Type, 'has', {\r\n                    get : function(){\r\n                        // workaround for sinon.js and other libraries overriding 'has'\r\n                        return this._has || this.options();\r\n                    },\r\n                    set : function( value ){ this._has = value; }\r\n                } );\r\n            }\r\n        };\r\n    })()\r\n} );\r\n\r\nOptions.prototype.Attribute = Attribute;\r\nOptions.prototype.attribute = Options.prototype.options;\r\n\r\nfunction createOptions( spec ){\r\n    return new Options( spec );\r\n}\r\n\r\ncreateOptions.Type = Attribute;\r\ncreateOptions.create = function( options, name ){\r\n    if( !( options && options instanceof Options ) ){\r\n        options = new Options( { typeOrValue : options } );\r\n    }\r\n\r\n    return options.createAttribute( name );\r\n};\r\n\r\nmodule.exports = createOptions;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/attribute.js\n ** module id = 8\n ** module chunks = 0\n **/","var Backbone = require( './backbone+' ),\r\n    Model    = require( './model' ),\r\n    error    = require( './errors' ),\r\n    _        = require( 'underscore' );\r\n\r\nvar CollectionProto = Backbone.Collection.prototype;\r\n\r\nfunction wrapCall( func ){\r\n    return function(){\r\n        if( !this.__changing++ ){\r\n            this.trigger( 'before:change' );\r\n        }\r\n\r\n        var res = func.apply( this, arguments );\r\n\r\n        if( !--this.__changing ){\r\n            this.trigger( 'after:change' );\r\n        }\r\n\r\n        return res;\r\n    };\r\n}\r\n\r\nmodule.exports = Backbone.Collection.extend( {\r\n    triggerWhenChanged : Backbone.VERSION >= '1.2.0' ? 'update change reset' : 'add remove change reset',\r\n    __class            : 'Collection',\r\n\r\n    model : Model,\r\n\r\n    isValid : function( options ){\r\n        return this.every( function( model ){\r\n            return model.isValid( options );\r\n        } );\r\n    },\r\n\r\n    get : function( obj ){\r\n        if( obj == null ){\r\n            return void 0;\r\n        }\r\n        return typeof obj === 'object' ? this._byId[ obj.id ] || this._byId[ obj.cid ] : this._byId[ obj ];\r\n    },\r\n\r\n    deepClone : function(){ return this.clone( { deep : true } ); },\r\n\r\n    clone : function( options ){\r\n        var models = options && options.deep ?\r\n                     this.map( function( model ){\r\n                         return model.clone( options );\r\n                     } ) : this.models;\r\n\r\n        return new this.constructor( models );\r\n    },\r\n\r\n    __changing : 0,\r\n\r\n    set : wrapCall( function( models, options ){\r\n        if( models ){\r\n            if( typeof models !== 'object' || !( models instanceof Array || models instanceof Model ||\r\n                Object.getPrototypeOf( models ) === Object.prototype ) ){\r\n                error.wrongCollectionSetArg( this, models );\r\n            }\r\n        }\r\n\r\n        return CollectionProto.set.call( this, models, options );\r\n    } ),\r\n\r\n    remove : wrapCall( CollectionProto.remove ),\r\n    add    : wrapCall( CollectionProto.add ),\r\n    reset  : wrapCall( CollectionProto.reset ),\r\n    sort   : wrapCall( CollectionProto.sort ),\r\n\r\n    getModelIds : function(){ return _.pluck( this.models, 'id' ); },\r\n\r\n    createSubset : function( models, options ){\r\n        var SubsetOf = this.constructor.subsetOf( this ).createAttribute().type;\r\n        return new SubsetOf( models, options );\r\n    }\r\n}, {\r\n    // Cache for subsetOf collection subclass.\r\n    __subsetOf : null,\r\n    defaults   : function( attrs ){\r\n        return this.prototype.model.extend( { defaults : attrs } ).Collection;\r\n    },\r\n    extend     : function(){\r\n        // Need to subsetOf cache when extending the collection\r\n        var This = Backbone.Collection.extend.apply( this, arguments );\r\n        This.__subsetOf = null;\r\n        return This;\r\n    }\r\n} );\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/collection.js\n ** module id = 9\n ** module chunks = 0\n **/","// Nested Relations\r\n//=================\r\n\r\nvar bbVersion  = require( 'backbone' ).VERSION,\r\n    attribute  = require( './attribute' ),\r\n    Collection = require( './collection' ),\r\n    _          = require( 'underscore' );\r\n\r\nfunction parseReference( collectionRef ){\r\n    switch( typeof collectionRef ){\r\n    case 'function' :\r\n        return collectionRef;\r\n    case 'object'   :\r\n        return function(){ return collectionRef; };\r\n    case 'string'   :\r\n        return new Function( 'return this.' + collectionRef );\r\n    }\r\n}\r\n\r\nexports.from = function( masterCollection ){\r\n    var getMaster = parseReference( masterCollection );\r\n\r\n    function clone( value ){\r\n        return value && typeof value === 'object' ? value.id : value;\r\n    }\r\n\r\n    var ModelRefAttribute = attribute.Type.extend( {\r\n        toJSON : clone,\r\n        clone  : clone,\r\n\r\n        isChanged : function( a, b ){\r\n            // refs are equal when their id is equal.\r\n            var aId = a && typeof a == 'object' ? a.id : a,\r\n                bId = b && typeof b == 'object' ? b.id : b;\r\n\r\n            return aId !== bId;\r\n        },\r\n\r\n        get : function( objOrId, name ){\r\n            if( typeof objOrId !== 'object' ){\r\n                // Resolve reference.\r\n                var master = getMaster.call( this );\r\n\r\n                if( master && master.length ){\r\n                    // Silently update attribute with object form master.\r\n                    objOrId = master.get( objOrId ) || null;\r\n                    this.attributes[ name ] = objOrId;\r\n\r\n                    // Subscribe for events manually. delegateEvents won't be invoked.\r\n                    var attrSpec = this.__attributes[ name ];\r\n                    objOrId && attrSpec.events && this.listenTo( objOrId, attrSpec.events );\r\n                }\r\n                else{\r\n                    objOrId = null;\r\n                }\r\n            }\r\n\r\n            return objOrId;\r\n        }\r\n    } );\r\n\r\n    var options = attribute( { value : null } );\r\n    options.Attribute = ModelRefAttribute; //todo: consider moving this to the attrSpec\r\n    return options;\r\n};\r\n\r\nvar CollectionProto = Collection.prototype;\r\n\r\nvar refsCollectionSpec = {\r\n    triggerWhenChanged : bbVersion >= '1.2.0' ? 'update reset' : 'add remove reset', // don't bubble changes from models\r\n    __class            : 'Collection.SubsetOf',\r\n\r\n    resolvedWith : null,\r\n    refs         : null,\r\n\r\n    toJSON : function(){\r\n        return this.refs || _.pluck( this.models, 'id' );\r\n    },\r\n\r\n    clone : function( options ){\r\n        var copy = CollectionProto.clone.call( this, _.omit( options, 'deep' ) );\r\n        copy.resolvedWith = this.resolvedWith;\r\n        copy.refs = this.refs;\r\n\r\n        return copy;\r\n    },\r\n\r\n    parse : function( raw ){\r\n        var models = [];\r\n\r\n        if( this.resolvedWith ){\r\n            models = _.compact( _.map( raw, function( id ){\r\n                return this.resolvedWith.get( id );\r\n            }, this ) );\r\n        }\r\n        else{\r\n            this.refs = raw;\r\n        }\r\n\r\n        return models;\r\n    },\r\n\r\n    toggle : function( modelOrId, inSet ){\r\n        var model = this.resolvedWith.get( modelOrId ),\r\n            toggle = inSet === void 0;\r\n\r\n        if( this.get( model ) ){\r\n            if( toggle || !inSet ) this.remove( model );\r\n        }\r\n        else{\r\n            if( toggle || inSet ) this.add( model );\r\n        }\r\n    },\r\n\r\n    addAll    : function(){\r\n        this.reset( this.resolvedWith.models );\r\n    },\r\n\r\n    removeAll : function(){\r\n        this.reset();\r\n    },\r\n\r\n    toggleAll : function(){\r\n        if( this.length ){\r\n            this.removeAll();\r\n        }\r\n        else{\r\n            this.addAll();\r\n        }\r\n    },\r\n\r\n    getModelIds : function(){ return this.refs || _.pluck( this.models, 'id' ); },\r\n\r\n    justOne   : function( arg ){\r\n        var model = arg instanceof Backbone.Model ? arg : this.resolvedWith.get( arg );\r\n        this.set( [ model ] );\r\n    },\r\n\r\n    set       : function( models, upperOptions ){\r\n        var options = { merge : false };\r\n\r\n        if( models ){\r\n            if( models instanceof Array && models.length && typeof models[ 0 ] !== 'object' ){\r\n                options.merge = options.parse = true;\r\n            }\r\n        }\r\n\r\n        CollectionProto.set.call( this, models, _.defaults( options, upperOptions ) );\r\n    },\r\n\r\n    resolve : function( collection ){\r\n        if( collection && collection.length ){\r\n            this.resolvedWith = collection;\r\n\r\n            if( this.refs ){\r\n                this.reset( this.refs, { silent : true } );\r\n                this.refs = null;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nexports.subsetOf = function( masterCollection ){\r\n    var SubsetOf = this.__subsetOf || ( this.__subsetOf = this.extend( refsCollectionSpec ) );\r\n    var getMaster = parseReference( masterCollection );\r\n\r\n    return attribute( {\r\n        type : SubsetOf,\r\n\r\n        get : function( refs ){\r\n            !refs || refs.resolvedWith || refs.resolve( getMaster.call( this ) );\r\n            return refs;\r\n        }\r\n    } );\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/relations.js\n ** module id = 10\n ** module chunks = 0\n **/","// Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\r\n// (c) 2011 Colin Snover <http://zetafleet.com>\r\n// Released under MIT license.\r\n\r\n// Attribute Type definitions for core JS types\r\n// ============================================\r\nvar attribute  = require( './attribute' ),\r\n    modelSet   = require( './modelset' ),\r\n    Model      = require( './model' ),\r\n    Collection = require( './collection' );\r\n\r\n// Constructors Attribute\r\n// ----------------\r\nattribute.Type.extend( {\r\n    cast : function( value ){\r\n        return value == null || value instanceof this.type ? value : new this.type( value );\r\n    },\r\n\r\n    clone : function( value, options ){\r\n        // delegate to clone function or deep clone through serialization\r\n        return value.clone ? value.clone( value, options ) : this.cast( JSON.parse( JSON.stringify( value ) ) );\r\n    }\r\n} ).attach( Function.prototype );\r\n\r\n// Date Attribute\r\n// ----------------------\r\nvar numericKeys    = [ 1, 4, 5, 6, 7, 10, 11 ],\r\n    msDatePattern  = /\\/Date\\(([0-9]+)\\)\\//,\r\n    isoDatePattern = /^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\r\n\r\nfunction parseDate( date ){\r\n    var msDate, timestamp, struct, minutesOffset = 0;\r\n\r\n    if( msDate = msDatePattern.exec( date ) ){\r\n        timestamp = Number( msDate[ 1 ] );\r\n    }\r\n    else if( ( struct = isoDatePattern.exec( date )) ){\r\n        // avoid NaN timestamps caused by undefined values being passed to Date.UTC\r\n        for( var i = 0, k; ( k = numericKeys[ i ] ); ++i ){\r\n            struct[ k ] = +struct[ k ] || 0;\r\n        }\r\n\r\n        // allow undefined days and months\r\n        struct[ 2 ] = (+struct[ 2 ] || 1) - 1;\r\n        struct[ 3 ] = +struct[ 3 ] || 1;\r\n\r\n        if( struct[ 8 ] !== 'Z' && struct[ 9 ] !== undefined ){\r\n            minutesOffset = struct[ 10 ] * 60 + struct[ 11 ];\r\n\r\n            if( struct[ 9 ] === '+' ){\r\n                minutesOffset = 0 - minutesOffset;\r\n            }\r\n        }\r\n\r\n        timestamp =\r\n            Date.UTC( struct[ 1 ], struct[ 2 ], struct[ 3 ], struct[ 4 ], struct[ 5 ] + minutesOffset, struct[ 6 ],\r\n                struct[ 7 ] );\r\n    }\r\n    else{\r\n        timestamp = Date.parse( date );\r\n    }\r\n\r\n    return timestamp;\r\n}\r\n\r\nattribute.Type.extend( {\r\n    cast : function( value ){\r\n        return value == null || value instanceof Date ? value :\r\n               new Date( typeof value === 'string' ? parseDate( value ) : value )\r\n    },\r\n\r\n    toJSON : function( value ){ return value && value.toJSON(); },\r\n\r\n    isChanged : function( a, b ){ return ( a && +a ) !== ( b && +b ); },\r\n    clone     : function( value ){ return value && new Date( +value ); }\r\n} ).attach( Date );\r\n\r\n// Primitive Types\r\n// ----------------\r\n// Global Mock for missing Integer data type...\r\n// -------------------------------------\r\nInteger = function( x ){ return x ? Math.round( x ) : 0; };\r\n\r\nattribute.Type.extend( {\r\n    create : function(){ return this.type(); },\r\n\r\n    toJSON : function( value ){ return value; },\r\n    cast   : function( value ){ return value == null ? null : this.type( value ); },\r\n\r\n    isChanged : function( a, b ){ return a !== b; },\r\n\r\n    clone : function( value ){ return value; }\r\n} ).attach( Number, Boolean, String, Integer );\r\n\r\n// Array Type\r\n// ---------------\r\nattribute.Type.extend( {\r\n    toJSON : function( value ){ return value; },\r\n    cast   : function( value ){\r\n        // Fix incompatible constructor behaviour of Array...\r\n        return value == null || value instanceof Array ? value : [ value ];\r\n    }\r\n} ).attach( Array );\r\n\r\n// Backbone Attribute\r\n// ----------------\r\n\r\n// helper attrSpec mock to force attribute update\r\nvar bbForceUpdateAttr = new ( attribute.Type.extend( {\r\n    isChanged : function(){ return true; }\r\n} ) );\r\n\r\nvar setAttrs      = modelSet.setAttrs,\r\n    setSingleAttr = modelSet.setSingleAttr;\r\n\r\nattribute.Type.extend( {\r\n    create : function( options ){ return new this.type( null, options ); },\r\n    clone  : function( value, options ){ return value && value.clone( options ); },\r\n    toJSON : function( value ){ return value && value.toJSON(); },\r\n\r\n    isChanged : function( a, b ){ return a !== b; },\r\n\r\n    isBackboneType : true,\r\n    isModel        : true,\r\n\r\n    createPropertySpec : function(){\r\n        // if there are nested changes detection enabled, disable optimized setter\r\n        if( this.__events ){\r\n            return (function( self, name, get ){\r\n                return {\r\n                    set : function( value ){\r\n                        var attrs = {};\r\n                        attrs[ name ] = value;\r\n                        setAttrs( this, attrs );\r\n                    },\r\n\r\n                    get : get ? function(){ return get.call( this, this.attributes[ name ], name ); } :\r\n                          function(){ return this.attributes[ name ]; }\r\n                }\r\n            })( this, this.name, this.get );\r\n        }\r\n        else{\r\n            return attribute.Type.prototype.createPropertySpec.call( this );\r\n        }\r\n    },\r\n\r\n    cast : function( value, options, model, name ){\r\n        var incompatibleType          = value != null && !( value instanceof this.type ),\r\n            existingModelOrCollection = model.attributes[ name ];\r\n\r\n        if( incompatibleType ){\r\n            if( existingModelOrCollection ){ // ...delegate update for existing object 'set' method\r\n                if( options && options.parse && this.isModel ){ // handle inconsistent backbone's parse implementation\r\n                    value = existingModelOrCollection.parse( value );\r\n                }\r\n\r\n                existingModelOrCollection.set( value, options );\r\n                value = existingModelOrCollection;\r\n            }\r\n            else{ // ...or create a new object, if it's not exist\r\n                value = new this.type( value, options );\r\n            }\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    initialize : function( spec ){\r\n        var name               = this.name,\r\n            triggerWhenChanged = this.triggerWhenChanged || spec.type.prototype.triggerWhenChanged;\r\n\r\n        this.isModel = this.type === Model || this.type.prototype instanceof Model;\r\n\r\n        if( triggerWhenChanged ){\r\n            // for collection, add transactional methods to join change events on bubbling\r\n            this.__events = this.isModel ? {} : {\r\n                'before:change' : modelSet.__begin,\r\n                'after:change'  : modelSet.__commit\r\n            };\r\n\r\n            this.__events[ triggerWhenChanged ] = function handleNestedChange(){\r\n                var attr = this.attributes[ name ];\r\n\r\n                if( this.__duringSet ){\r\n                    this.__nestedChanges[ name ] = attr;\r\n                }\r\n                else{\r\n                    setSingleAttr( this, name, attr, bbForceUpdateAttr );\r\n                }\r\n            };\r\n        }\r\n    }\r\n} ).attach( Model, Collection );\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/metatypes.js\n ** module id = 11\n ** module chunks = 0\n **/","var Backbone   = require( './backbone+' ),\r\n    Model      = require( './model' ),\r\n    Collection = require( './collection' ),\r\n    _          = require( 'underscore' );\r\n\r\nvar _store = null;\r\n\r\n// Exports native property spec for model store\r\nexports.get = function(){ return _store; };\r\n\r\nexports.set = function( spec ){\r\n    _.each( spec, function( Type, name ){\r\n        Type.options && ( spec[name] = Type.options( {\r\n            get : function( value ){\r\n                if( !this.resolved[name] ){\r\n                    value.fetch && value.fetch();\r\n                    this.resolved[name] = true;\r\n                }\r\n\r\n                return value;\r\n            },\r\n\r\n            set : function( value ){\r\n                value.length || ( this.resolved[name] = false );\r\n                return value;\r\n            }\r\n        } ) );\r\n    } );\r\n\r\n    var $ = Backbone.$;\r\n\r\n    var Cache = Model.extend( {\r\n        attributes : spec,\r\n        resolved   : {},\r\n\r\n        initialize   : function(){\r\n            this.resolved = {};\r\n            this.installHooks();\r\n        },\r\n        installHooks : function(){\r\n            var self = this;\r\n\r\n            _.each( this.attributes, function( element, name ){\r\n                if( !element ){\r\n                    return;\r\n                }\r\n                var fetch = element.fetch;\r\n                if( fetch ){\r\n                    element.fetch = function(){\r\n                        self.resolved[name] = true;\r\n                        return fetch.apply( this, arguments );\r\n                    }\r\n                }\r\n\r\n                if( element instanceof Collection && element.length ){\r\n                    this.resolved[name] = true;\r\n                }\r\n            }, this );\r\n        },\r\n\r\n        fetch : function(){\r\n            var xhr         = [],\r\n                objsToFetch = arguments.length ? arguments : _.keys( this.resolved );\r\n\r\n            _.each( objsToFetch, function( name ){\r\n                var attr = this.attributes[name];\r\n                attr.fetch && xhr.push( attr.fetch() );\r\n            }, this );\r\n\r\n            return $ && $.when && $.when.apply( Backbone.$, xhr );\r\n        },\r\n\r\n        clear : function(){\r\n            var attrs = this.defaults();\r\n            arguments.length && ( attrs = _.pick( attrs, _.toArray( arguments ) ) );\r\n            this.set( attrs );\r\n            this.installHooks();\r\n            return this;\r\n        }\r\n    } );\r\n\r\n    Model.prototype.store = _store = new Cache();\r\n};\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/store.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}